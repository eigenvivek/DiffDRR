# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/api/02_detector.ipynb.

# %% ../notebooks/api/02_detector.ipynb 3
from __future__ import annotations

import torch
from fastcore.basics import patch
from torch.nn.functional import normalize

# %% auto 0
__all__ = ['Detector', 'diffdrr_to_deepdrr']

# %% ../notebooks/api/02_detector.ipynb 4
try:
    import pytorch3d
except ModuleNotFoundError:
    install = "https://github.com/facebookresearch/pytorch3d/blob/main/INSTALL.md"
    raise ModuleNotFoundError(
        f"PyTorch3D is not installed, which is required to parameterize camera poses. See installation instructions here: {install}"
    )

# %% ../notebooks/api/02_detector.ipynb 6
class Detector(torch.nn.Module):
    """Construct a 6 DoF X-ray detector system. This model is based on a C-Arm."""

    def __init__(
        self,
        sdr: float,  # Source-to-detector radius (half of the source-to-detector distance)
        height: int,  # Height of the X-ray detector
        width: int,  # Width of the X-ray detector
        delx: float,  # Pixel spacing in the X-direction
        dely: float,  # Pixel spacing in the Y-direction
        n_subsample: int | None = None,  # Number of target points to randomly sample
        reverse_x_axis: bool = False,  # If pose includes reflection (in E(3) not SE(3)), reverse x-axis
        mode: str = "perspective",  # Either `perspective` or `orthographic`
    ):
        super().__init__()
        self.sdr = sdr
        self.height = height
        self.width = width
        self.delx = delx
        self.dely = dely
        self.n_subsample = n_subsample
        if self.n_subsample is not None:
            self.subsamples = []
        self.reverse_x_axis = reverse_x_axis
        if mode not in ["perspective", "orthographic"]:
            raise ValueError(
                f"mode must be 'perspective' or 'orthographic', not {mode}"
            )
        self.mode = mode

        # Initialize the source and detector plane in default positions (along the x-axis)
        source, target = self._initialize_carm()
        self.register_buffer("source", source)
        self.register_buffer("target", target)

# %% ../notebooks/api/02_detector.ipynb 7
@patch
def _initialize_carm(self: Detector):
    """Initialize the default position for the source and detector plane."""
    # Initialize the source on the x-axis
    if self.mode == "perspective":
        source = torch.tensor([[self.sdr, 0.0, 0.0]])
    else:
        source = torch.tensor([[1e6, 0.0, 0.0]])

    # Initialize the center of the detector plane on the negative x-axis
    center = torch.tensor([[-self.sdr, 0.0, 0.0]])

    # Use the standard basis for the detector plane
    basis = torch.tensor([[0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])

    # Construct the detector plane with different offsets for even or odd heights
    h_off = 1.0 if self.height % 2 else 0.5
    w_off = 1.0 if self.width % 2 else 0.5

    # Construct equally spaced points along the basis vectors
    t = (torch.arange(-self.height // 2, self.height // 2) + h_off) * self.delx
    s = (torch.arange(-self.width // 2, self.width // 2) + w_off) * self.dely
    if self.reverse_x_axis:
        s = -s
    coefs = torch.cartesian_prod(t, s).reshape(-1, 2)
    target = torch.einsum("cd,nc->nd", basis, coefs)
    target += center

    # Batch source and target
    source = source.unsqueeze(0)
    target = target.unsqueeze(0)

    if self.n_subsample is not None:
        sample = torch.randperm(self.height * self.width)[: int(self.n_subsample)]
        target = target[:, sample, :]
        self.subsamples.append(sample.tolist())
    return source, target

# %% ../notebooks/api/02_detector.ipynb 8
from pytorch3d.transforms import Transform3d

from .utils import convert


@patch
def forward(
    self: Detector,
    rotation: torch.Tensor,  # Some (batched) representation of a rotation
    translation: torch.Tensor,  # Batch of C-arm translation (bx, by, bz)
    parameterization: str,  # Specifies the representation of the rotation
    convention: str,  # If parameterization is Euler angles, specify convention
):
    """Create source and target points for X-rays to trace through the volume."""
    if parameterization == "euler_angles" and convention is None:
        raise ValueError(
            "convention for Euler angles must be specified as a 3 letter combination of [X, Y, Z]"
        )

    # Convert rotation representation to a rotation matrix, R
    # Transpose R to convert to right-handed convention for PyTorch3D
    R = convert(rotation, parameterization, "matrix", input_convention=convention)
    R = R.transpose(-1, -2)
    t = Transform3d(device=rotation.device).rotate(R).translate(translation)
    source, target = make_xrays(t, self.source, self.target)
    return source, target

# %% ../notebooks/api/02_detector.ipynb 9
def make_xrays(t: Transform3d, source: torch.Tensor, target: torch.Tensor):
    source = t.transform_points(source)
    target = t.transform_points(target)
    return source, target

# %% ../notebooks/api/02_detector.ipynb 10
def diffdrr_to_deepdrr(euler_angles):
    alpha, beta, gamma = euler_angles.unbind(-1)
    return torch.stack([beta, alpha, gamma], dim=1)
