# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/api/01_renderers.ipynb.

# %% auto 0
__all__ = ['Siddon', 'Trilinear']

# %% ../notebooks/api/01_renderers.ipynb 3
import torch

# %% ../notebooks/api/01_renderers.ipynb 7
class Siddon(torch.nn.Module):
    """Differentiable X-ray renderer implemented with Siddon's method for exact raytracing."""

    def __init__(self, eps=1e-8):
        super().__init__()
        self.eps = eps

    def dims(self, volume):
        return torch.tensor(volume.shape).to(volume) + 1

    def maxidx(self, volume):
        return volume.numel() - 1

    def forward(self, volume, spacing, source, target):
        dims = self.dims(volume)
        maxidx = self.maxidx(volume)

        alphas = _get_alphas(source, target, spacing, dims, self.eps)
        alphamid = (alphas[..., 0:-1] + alphas[..., 1:]) / 2
        voxels = _get_voxel(
            alphamid, source, target, volume, spacing, dims, maxidx, self.eps
        )

        # Step length for alphas out of range will be nan
        # These nans cancel out voxels convereted to 0 index
        step_length = torch.diff(alphas, dim=-1)
        weighted_voxels = voxels * step_length

        drr = torch.nansum(weighted_voxels, dim=-1)
        raylength = (target - source + self.eps).norm(dim=-1)
        drr *= raylength
        return drr

# %% ../notebooks/api/01_renderers.ipynb 8
def _get_alphas(source, target, spacing, dims, eps):
    # Get the CT sizing and spacing parameters
    alphax = torch.arange(dims[0]).to(source) * spacing[0]
    alphay = torch.arange(dims[1]).to(source) * spacing[1]
    alphaz = torch.arange(dims[2]).to(source) * spacing[2]

    # Get the alpha at each plane intersection
    sx, sy, sz = source[..., 0], source[..., 1], source[..., 2]
    alphax = alphax.expand(len(source), 1, -1) - sx.unsqueeze(-1)
    alphay = alphay.expand(len(source), 1, -1) - sy.unsqueeze(-1)
    alphaz = alphaz.expand(len(source), 1, -1) - sz.unsqueeze(-1)

    sdd = target - source + eps
    alphax = alphax / sdd[..., 0].unsqueeze(-1)
    alphay = alphay / sdd[..., 1].unsqueeze(-1)
    alphaz = alphaz / sdd[..., 2].unsqueeze(-1)
    alphas = torch.cat([alphax, alphay, alphaz], dim=-1)

    # Get the alphas within the range [alphamin, alphamax]
    alphamin, alphamax = _get_alpha_minmax(source, target, spacing, dims, eps)
    good_idxs = torch.logical_and(alphas >= alphamin, alphas <= alphamax)
    alphas[~good_idxs] = torch.nan

    # Sort the alphas by ray, putting nans at the end of the list
    alphas = torch.sort(alphas, dim=-1).values

    # Drop indices where alphas for all rays are nan
    alphas = alphas[..., ~alphas.isnan().all(dim=0).all(dim=0)]

    return alphas


def _get_alpha_minmax(source, target, spacing, dims, eps):
    sdd = target - source + eps
    planes = torch.zeros(3).to(source)
    alpha0 = (planes * spacing - source) / sdd
    planes = (dims - 1).to(source)
    alpha1 = (planes * spacing - source) / sdd
    alphas = torch.stack([alpha0, alpha1]).to(source)

    alphamin = alphas.min(dim=0).values.max(dim=-1).values.unsqueeze(-1)
    alphamax = alphas.max(dim=0).values.min(dim=-1).values.unsqueeze(-1)

    alphamin = torch.where(alphamin < 0.0, 0.0, alphamin)
    alphamax = torch.where(alphamax > 1.0, 1.0, alphamax)
    return alphamin, alphamax


def _get_voxel(alpha, source, target, volume, spacing, dims, maxidx, eps):
    idxs = _get_index(alpha, source, target, spacing, dims, maxidx, eps)
    return torch.take(volume, idxs)


def _get_index(alpha, source, target, spacing, dims, maxidx, eps):
    sdd = target - source + eps
    idxs = source.unsqueeze(1) + alpha.unsqueeze(-1) * sdd.unsqueeze(2)
    idxs = idxs / spacing
    idxs = idxs.trunc()
    # Conversion to long makes nan->-inf, so temporarily replace them with 0
    # This is cancelled out later by multiplication by nan step_length
    idxs = (
        idxs[..., 0] * (dims[1] - 1) * (dims[2] - 1)
        + idxs[..., 1] * (dims[2] - 1)
        + idxs[..., 2]
    ).long() + 1
    idxs[idxs < 0] = 0
    idxs[idxs > maxidx] = maxidx
    return idxs

# %% ../notebooks/api/01_renderers.ipynb 12
from torch.nn.functional import grid_sample


class Trilinear(torch.nn.Module):
    """Differentiable X-ray renderer implemented with trilinear interpolation."""

    def __init__(
        self,
        near=0.0,
        far=1.0,
        mode="bilinear",
        eps=1e-8,
    ):
        super().__init__()
        self.near = near
        self.far = far
        self.mode = mode
        self.eps = eps

    def dims(self, volume):
        return torch.tensor(volume.shape).to(volume) - 1

    def forward(
        self, volume, spacing, source, target, n_points=250, align_corners=True
    ):
        # Get the raylength and reshape sources
        raylength = (source - target + self.eps).norm(dim=-1)
        source = source[:, None, :, None, :]
        target = target[:, None, :, None, :]

        # Sample points along the rays and rescale to [-1, 1]
        alphas = torch.linspace(self.near, self.far, n_points).to(volume)
        alphas = alphas[None, None, None, :, None]
        rays = source + alphas * (target - source)
        rays = 2 * rays / (spacing * self.dims(volume)) - 1

        # Reorder array to match torch conventions
        volume = volume.permute(2, 1, 0)

        # Render the DRR
        batch_size = len(rays)
        vol = volume[None, None, :, :, :].expand(batch_size, -1, -1, -1, -1)
        drr = grid_sample(vol, rays, mode=self.mode, align_corners=align_corners)
        drr = drr[:, 0, 0].sum(dim=-1)
        drr *= raylength / n_points
        return drr
