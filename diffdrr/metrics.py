# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/api/05_metrics.ipynb.

# %% ../notebooks/api/05_metrics.ipynb 3
from __future__ import annotations

import torch

# %% auto 0
__all__ = ['NormalizedCrossCorrelation2d', 'MultiscaleNormalizedCrossCorrelation2d', 'GradientNormalizedCrossCorrelation2d',
           'MutualInformation', 'LogGeodesicSE3', 'DoubleGeodesicSE3']

# %% ../notebooks/api/05_metrics.ipynb 6
from einops import rearrange


def to_patches(x, patch_size):
    x = x.unfold(2, patch_size, step=1).unfold(3, patch_size, step=1).contiguous()
    return rearrange(x, "b c p1 p2 h w -> b (c p1 p2) h w")

# %% ../notebooks/api/05_metrics.ipynb 7
class NormalizedCrossCorrelation2d(torch.nn.Module):
    """Compute Normalized Cross Correlation between two batches of images."""

    def __init__(self, patch_size=None, eps=1e-5):
        super().__init__()
        self.patch_size = patch_size
        self.eps = eps

    def forward(self, x1, x2):
        if self.patch_size is not None:
            x1 = to_patches(x1, self.patch_size)
            x2 = to_patches(x2, self.patch_size)
        assert x1.shape == x2.shape, "Input images must be the same size"
        _, c, h, w = x1.shape
        x1, x2 = self.norm(x1), self.norm(x2)
        score = torch.einsum("b...,b...->b", x1, x2)
        score /= c * h * w
        return score

    def norm(self, x):
        mu = x.mean(dim=[-1, -2], keepdim=True)
        var = x.var(dim=[-1, -2], keepdim=True, correction=0) + self.eps
        std = var.sqrt()
        return (x - mu) / std

# %% ../notebooks/api/05_metrics.ipynb 8
class MultiscaleNormalizedCrossCorrelation2d(torch.nn.Module):
    """Compute Normalized Cross Correlation between two batches of images at multiple scales."""

    def __init__(self, patch_sizes=[None], patch_weights=[1.0], eps=1e-5):
        super().__init__()

        assert len(patch_sizes) == len(patch_weights), "Each scale must have a weight"
        self.nccs = [
            NormalizedCrossCorrelation2d(patch_size) for patch_size in patch_sizes
        ]
        self.patch_weights = patch_weights

    def forward(self, x1, x2):
        scores = []
        for weight, ncc in zip(self.patch_weights, self.nccs):
            scores.append(weight * ncc(x1, x2))
        return torch.stack(scores, dim=0).sum(dim=0)

# %% ../notebooks/api/05_metrics.ipynb 9
from torchvision.transforms.functional import gaussian_blur


class Sobel(torch.nn.Module):
    def __init__(self, sigma):
        super().__init__()
        self.sigma = sigma
        self.filter = torch.nn.Conv2d(
            in_channels=1,
            out_channels=2,  # X- and Y-gradients
            kernel_size=3,
            stride=1,
            padding=1,  # Return images of the same size as inputs
            bias=False,
        )

        Gx = torch.tensor([[1, 0, -1], [2, 0, -2], [1, 0, -1]]).to(torch.float32)
        Gy = torch.tensor([[1, 2, 1], [0, 0, 0], [-1, -2, -1]]).to(torch.float32)
        G = torch.stack([Gx, Gy]).unsqueeze(1)
        self.filter.weight = torch.nn.Parameter(G, requires_grad=False)

    def forward(self, img):
        x = gaussian_blur(img, 5, self.sigma)
        x = self.filter(img)
        return x

# %% ../notebooks/api/05_metrics.ipynb 10
class GradientNormalizedCrossCorrelation2d(NormalizedCrossCorrelation2d):
    """Compute Normalized Cross Correlation between the image gradients of two batches of images."""

    def __init__(self, patch_size=None, sigma=1.0, **kwargs):
        super().__init__(patch_size, **kwargs)
        self.sobel = Sobel(sigma)

    def forward(self, x1, x2):
        return super().forward(self.sobel(x1), self.sobel(x2))

# %% ../notebooks/api/05_metrics.ipynb 11
from kornia.enhance.histogram import marginal_pdf, joint_pdf


class MutualInformation(torch.nn.Module):
    """Mutual Information."""

    def __init__(self, sigma=0.1, num_bins=256, epsilon=1e-10, normalize=True):
        super().__init__()
        self.register_buffer("sigma", torch.tensor(sigma))
        self.register_buffer("bins", torch.linspace(0.0, 1.0, num_bins))
        self.epsilon = epsilon
        self.normalize = normalize

    def forward(self, x1, x2):
        assert x1.shape == x2.shape
        B, C, H, W = x1.shape

        x1 = x1.view(B, H * W, C)
        x2 = x2.view(B, H * W, C)

        pdf_x1, kernel_values1 = marginal_pdf(x1, self.bins, self.sigma, self.epsilon)
        pdf_x2, kernel_values2 = marginal_pdf(x2, self.bins, self.sigma, self.epsilon)
        pdf_x1x2 = joint_pdf(kernel_values1, kernel_values2)

        H_x1 = -(pdf_x1 * (pdf_x1 + self.epsilon).log2()).sum(dim=1)
        H_x2 = -(pdf_x2 * (pdf_x2 + self.epsilon).log2()).sum(dim=1)
        H_x1x2 = -(pdf_x1x2 * (pdf_x1x2 + self.epsilon).log2()).sum(dim=(1, 2))

        mutual_information = H_x1 + H_x2 - H_x1x2
        if self.normalize:
            mutual_information = 2 * mutual_information / (H_x1 + H_x2)

        return mutual_information

# %% ../notebooks/api/05_metrics.ipynb 15
from .pose import RigidTransform, convert


class LogGeodesicSE3(torch.nn.Module):
    """
    Calculate the distance between transforms in the log-space of SE(3).
    """

    def __init__(self):
        super().__init__()

    def forward(
        self,
        pose_1: RigidTransform,
        pose_2: RigidTransform,
    ) -> Float[torch.Tensor, "b"]:
        return pose_2.compose(pose_1.inverse()).get_se3_log().norm(dim=1)

# %% ../notebooks/api/05_metrics.ipynb 18
from .pose import so3_log_map


class DoubleGeodesicSE3(torch.nn.Module):
    """
    Calculate the angular and translational geodesics between two SE(3) transformation matrices.
    """

    def __init__(
        self,
        sdd: float,  # Source-to-detector distance
        eps: float = 1e-6,  # Avoid overflows in sqrt
    ):
        super().__init__()
        self.sdr = sdd / 2
        self.eps = eps

        self.rot_geo = lambda r1, r2: self.sdr * so3_log_map(
            r1.transpose(-1, -2) @ r2
        ).norm(dim=-1)
        self.xyz_geo = lambda t1, t2: (t1 - t2).norm(dim=-1)

    def forward(self, pose_1: RigidTransform, pose_2: RigidTransform):
        r1, t1 = pose_1.convert("matrix")
        r2, t2 = pose_2.convert("matrix")
        rot = self.rot_geo(r1, r2)
        xyz = self.xyz_geo(t1, t2)
        dou = (rot.square() + xyz.square() + self.eps).sqrt()
        return rot, xyz, dou
